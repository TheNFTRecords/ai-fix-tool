<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>AI検出“補正”ツール｜簡易版（補正A/B/C）</title>
  <style>
    :root { --bg:#0b0d10; --panel:#141820; --ink:#e6ebf2; --muted:#8a95a7; --accent:#5eead4; }
    *{box-sizing:border-box}
    body{margin:0;background:linear-gradient(180deg,#0b0d10,#0e1218);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    header{padding:18px 20px;border-bottom:1px solid #1f2633;background:#0d1117;position:sticky;top:0;z-index:3}
    header h1{margin:0;font-size:16px;letter-spacing:.3px}
    .wrap{display:grid;grid-template-columns:300px 1fr;gap:16px;padding:16px}
    .panel{background:var(--panel);border:1px solid #1f2633;border-radius:16px;box-shadow:0 6px 18px rgba(0,0,0,.2)}
    .panel h2{margin:0;padding:12px 14px;border-bottom:1px solid #1f2633;font-size:14px;color:#c9d4e3}
    .panel .body{padding:12px 14px}
    .row{display:flex;align-items:center;gap:8px;margin:10px 0}
    label{min-width:110px;color:#cbd5e1;font-size:12px}
    input[type="file"],button{background:#0f1420;color:var(--ink);border:1px solid #283146;border-radius:10px;padding:10px;font-size:13px}
    .muted{color:var(--muted);font-size:12px}
    .footer{display:flex;gap:8px;justify-content:flex-end;margin-top:10px}
    .danger{border-color:#7f1d1d;color:#fecaca}
    .accent{border-color:#1f6f6a;background:#0b1f1d;color:#99f6e4}
    canvas{width:100%;height:auto;background:#0b0d10;border-bottom-left-radius:16px;border-bottom-right-radius:16px}
  </style>
</head>
<body>
  <header>
    <h1>AI検出“補正”ツール（簡易版｜補正A/B/Cのみ）</h1>
  </header>
  <div class="wrap">
    <!-- 左ペイン：設定 -->
    <section class="panel">
      <h2>設定</h2>
      <div class="body">
        <div class="row">
          <label>元画像</label>
          <input id="baseInput" type="file" accept="image/*" />
        </div>
        <div class="row">
          <label>補正パターン</label>
          <div>
            <div class="row" style="margin:6px 0"><input type="radio" name="preset" id="presetA" value="A" checked> <label for="presetA" style="min-width:auto">補正A</label></div>
            <div class="row" style="margin:6px 0"><input type="radio" name="preset" id="presetB" value="B"> <label for="presetB" style="min-width:auto">補正B</label></div>
            <div class="row" style="margin:6px 0"><input type="radio" name="preset" id="presetC" value="C"> <label for="presetC" style="min-width:auto">補正C</label></div>
          </div>
        </div>
        <div class="row">
          <label>強度</label>
          <div>
            <div class="row" style="margin:6px 0"><input type="radio" name="strength" id="stNorm" value="normal" checked> <label for="stNorm" style="min-width:auto">標準</label></div>
            <div class="row" style="margin:6px 0"><input type="radio" name="strength" id="stStrong" value="strong"> <label for="stStrong" style="min-width:auto">強め</label></div>
            <div class="row" style="margin:6px 0"><input type="radio" name="strength" id="stMax" value="max"> <label for="stMax" style="min-width:auto">最大</label></div>
          </div>
        </div>
        </div>
        <div class="muted">※ 補正はブラウザ内のみで適用され、ファイルはサーバーへ送信されません。</div>
        <div class="footer">
          <button id="exportPng" class="accent">PNG書き出し</button>
          <button id="exportJpg">JPG書き出し</button>
          <button id="clear" class="danger">画像クリア</button>
        </div>
      </div>
    </section>

    <!-- 右ペイン：プレビュー -->
    <section class="panel">
      <h2>プレビュー</h2>
      <canvas id="canvas"></canvas>
      <div class="body">
        <div class="muted">処理はすべてローカルで行われます。ファイルはサーバーに送信されません。</div>
      </div>
    </section>
  </div>

  <script>
    const MAX_SIDE = 4096;
    const baseInput = document.getElementById('baseInput');
    const exportPngBtn = document.getElementById('exportPng');
    const exportJpgBtn = document.getElementById('exportJpg');
    const clearBtn = document.getElementById('clear');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const presetRadios = Array.from(document.querySelectorAll('input[name="preset"]'));
    const strengthRadios = Array.from(document.querySelectorAll('input[name="strength"]'));

    // 非公開アセットの読み込み先（例）
    // 実運用では認証付き配信やビルド時埋め込みを推奨（クライアントのみでは秘匿は不可能）。
    // 手続き的テクスチャ（PNG不要・その場生成）

    // 各補正の固定パラメータ（UIでの変更不可）
    const PRESETS = {
      A: { alpha: 0.38, blend: 'soft-light' },
      B: { alpha: 0.34, blend: 'overlay'    },
      C: { alpha: 0.30, blend: 'multiply'   }
    };

    // 強度ごとの係数（アルファ倍率 + コントラスト増幅）
    const STRENGTHS = {
      normal: { alphaMul: 1.0, contrastK: 1.0, hatchDense: 1.0, grainGain: 1.0 },
      strong: { alphaMul: 1.25, contrastK: 1.25, hatchDense: 1.25, grainGain: 1.3 },
      max:    { alphaMul: 1.55, contrastK: 1.6,  hatchDense: 1.6,  grainGain: 1.6 }
    };

    let baseImage = null;
    let patternCache = {}; // key: preset|strength|w|h → canvas
    let currentPreset = 'A';

    function makeCanvas(w,h){ const c=document.createElement('canvas'); c.width=w; c.height=h; return c; }

    // A: フラクタルノイズ（紙ムラ）
    function genFractalNoise(w,h,contrastK){
      const c = makeCanvas(w,h), g=c.getContext('2d');
      const img = g.createImageData(w,h), d=img.data;
      const octaves = 4, freqBase = 64, ampFalloff = 0.5;
      for(let y=0;y<h;y++) for(let x=0;x<w;x++){
        let amp=1, val=0, norm=0;
        for(let o=0;o<octaves;o++){
          const f = Math.max(1, Math.floor(freqBase/(1<<o)));
          const sx = Math.floor(x/f), sy=Math.floor(y/f);
          const cellSeed = (sx*374761393 + sy*668265263 + o*2147483647)>>>0;
          const r = (cellSeed ^ (cellSeed<<13))>>>0; const rv = (r>>>8)%1000/1000;
          val += rv*amp; norm += amp; amp*=ampFalloff;
        }
        let nx = val/norm; // 0..1
        // コントラスト強化
        nx = (nx-0.5)*(contrastK||1)+0.5; if(nx<0) nx=0; if(nx>1) nx=1;
        const i=(y*w+x)*4; const v = Math.floor(nx*255);
        d[i]=d[i+1]=d[i+2]=v; d[i+3]=255;
      }
      g.putImageData(img,0,0); g.filter='blur(0.6px)'; g.drawImage(c,0,0); g.filter='none';
      return c;
    }

    // B: サイン波ハッチ（斜線）
    function genHatch(w,h,angleDeg=22,period=6,contrastK=1.0,densityMul=1.0){
      const c = makeCanvas(w,h), g=c.getContext('2d');
      const rad = angleDeg*Math.PI/180, cos=Math.cos(rad), sin=Math.sin(rad);
      const img = g.createImageData(w,h), d=img.data;
      const per = Math.max(2, period/ (densityMul||1));
      for(let y=0;y<h;y++) for(let x=0;x<w;x++){
        const u = x*cos + y*sin; let v = Math.sin((u/per)*2*Math.PI)*0.5 + 0.5;
        v = (v-0.5)*(contrastK||1)+0.5; if(v<0) v=0; if(v>1) v=1;
        const i=(y*w+x)*4, gv=Math.floor(v*255); d[i]=d[i+1]=d[i+2]=gv; d[i+3]=255;
      }
      g.putImageData(img,0,0); g.globalAlpha=0.9; g.filter='blur(0.4px)'; g.drawImage(c,0,0); g.filter='none';
      return c;
    }
    }

    // C: グレイン（粒状）
    function genGrain(w,h,gain=1.0){
      const c = makeCanvas(w,h), g=c.getContext('2d');
      const img = g.createImageData(w,h), d=img.data;
      for(let y=0;y<h;y++) for(let x=0;x<w;x++){
        const n1=Math.random(), n2=Math.random();
        let v = Math.pow(0.7*n1+0.3*n2,1.0); // ベース
        v = Math.min(1, v*gain);
        const i=(y*w+x)*4, gv=Math.floor(v*255); d[i]=d[i+1]=d[i+2]=gv; d[i+3]=255;
      }
      g.putImageData(img,0,0); g.globalAlpha=0.95; g.filter='blur(0.35px)'; g.drawImage(c,0,0); g.filter='none';
      return c;
    }
    }

    function getPattern(name,w,h){
      const strength = getStrengthKey();
      const key = `${name}|${strength}|${w}|${h}`;
      if (patternCache[key]) return patternCache[key];
      const st = STRENGTHS[strength];
      let out;
      if(name==='A') out=genFractalNoise(w,h,st.contrastK);
      else if(name==='B') out=genHatch(w,h,22,6,st.contrastK,st.hatchDense);
      else out=genGrain(w,h,st.grainGain);
      patternCache[key]=out; return out;
    }
    function getStrengthKey(){
      return strengthRadios.find(x=>x.checked)?.value || 'normal';
    }

    function loadImageFromFile(file) {
      return new Promise((resolve, reject) => {
        const url = URL.createObjectURL(file);
        const img = new Image();
        img.onload = () => resolve({img, url});
        img.onerror = reject;
        img.src = url;
      });
    }

    
    async function setBaseFromFile(file){
      const {img, url} = await loadImageFromFile(file);
      baseImage = img;
      const {w, h} = fitWithin(img.naturalWidth, img.naturalHeight, MAX_SIDE);
      canvas.width = w; canvas.height = h;
      draw();
      URL.revokeObjectURL(url);
    }

    function fitWithin(w, h, maxSide){
      if (Math.max(w,h) <= maxSide) return {w, h};
      const s = maxSide / Math.max(w,h);
      return {w: Math.round(w*s), h: Math.round(h*s)};
    }

    function draw(){
      ctx.clearRect(0,0,canvas.width, canvas.height);
      if (!baseImage){
        ctx.fillStyle = '#0b0d10';
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle = '#2c3a53';
        ctx.font = '14px ui-monospace, SFMono-Regular, Menlo, monospace';
        ctx.fillText('ここに画像を読み込み', 16, 28);
        return;
      }
      const iw = baseImage.naturalWidth, ih = baseImage.naturalHeight;
      const {w, h} = fitWithin(iw, ih, MAX_SIDE);
      canvas.width = w; canvas.height = h;
      ctx.drawImage(baseImage, 0, 0, w, h);

      const cfgBase = PRESETS[currentPreset];
      const st = STRENGTHS[getStrengthKey()];
      const pat = getPattern(currentPreset, w, h);
      if (!cfgBase || !st || !pat) return;

      ctx.save();
      ctx.globalAlpha = Math.min(1, cfgBase.alpha * st.alphaMul);
      ctx.globalCompositeOperation = cfgBase.blend;
      ctx.drawImage(pat, 0, 0, w, h);
      ctx.restore();
    }

    // イベント
    baseInput.addEventListener('change', async (e)=>{
      const f = e.target.files?.[0];
      if (f) await setBaseFromFile(f);
    });

    presetRadios.forEach(r=> r.addEventListener('change', ()=>{ currentPreset = presetRadios.find(x=>x.checked)?.value || 'A'; draw(); }));
    strengthRadios.forEach(r=> r.addEventListener('change', ()=>{ patternCache = {}; draw(); }));
    }));

    exportPngBtn.addEventListener('click', ()=> downloadCanvas('image/png'));
    exportJpgBtn.addEventListener('click', ()=> downloadCanvas('image/jpeg', 0.95));

    clearBtn.addEventListener('click', ()=>{
      baseImage = null; ctx.clearRect(0,0,canvas.width,canvas.height);
    });

    function downloadCanvas(mime, quality){
      if (!baseImage){ alert('先に元画像を読み込んでください'); return; }
      const url = canvas.toDataURL(mime, quality);
      const a = document.createElement('a');
      const ext = mime==='image/png'?'png':'jpg';
      a.download = `processed_${Date.now()}.${ext}`;
      a.href = url; a.click();
    }

    // 初期プレースホルダー
    canvas.width = 1024; canvas.height = 1024; draw();

    // ドラッグ&ドロップ（元画像）
    document.addEventListener('dragover', e=>{ e.preventDefault(); });
    document.addEventListener('drop', e=>{
      e.preventDefault();
      const files = Array.from(e.dataTransfer.files || []);
      if (!files.length) return;
      const img = files.find(f=> f.type.startsWith('image/'));
      if (img) setBaseFromFile(img);
    });

    // 手続き的テクスチャを使用するためプリロードは不要です。
    
  </script>
</body>
</html>
